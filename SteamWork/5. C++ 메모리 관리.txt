54. C++의 메모리 관리

# 목표
- TSharedPtr (공유 포인터)가 무엇인지 알아보자

# 스택과 힙에서는 어떤 일이 일어나는가
- 둘은 매우 다르게 사용되는 두 개의 메모리 세그먼트
- 스택은 매우 구조화된 방식으로 사용하면서, 힙은 지저분한 방식으로 사용됨

예)
스택 : 
	[Main]
	[GameLoop]
	[Mannequin::Tick()]
	[FVector::DotProduct()]
와 같은 방식으로 조직화되어 처리됨.
허나, 스택의 경우 호출된 함수 사이에 메모리가 이동하기를 원할 때 문제가 발생함.

힙 :
게임에서, 플레이어가 다른 플레이어를 공격한 이벤트를 호출하거나
새로운 게임 액터를 생성하거나 하는 이벤트들은 모두 힙에서 일어난다.

이처럼 스택은 딱 정리되어있고, 힙은 이벤트에 따른 변화가 일어난다.

따라서, 우리는 힙에서 일어나고 있는 복잡한 상황으로부터 어떻게 질서를 만들 수 있을지에 대해 알아볼 것임.

# CPP 접근 방식 중 하나는 모든 작업을 수동으로 하는 것이다.
- 새 플레이어를 만들려면 힙에 필요한 메모리를 할당하고 해당 포인터를 추적해야 함.
- 꼭 할당하기 전 그 지점이 비어있는지 확인하는 것을 기억하자.
- 클래스의 소멸자에서 소멸될 때

# 참조 카운팅
- 멀티플레이 환경에서 참조 카운팅을 통해 해당 액터를 소멸시킬지 말지를 결정할 수 있음
- 사람들이 참조하고 있을 때 마다 +1, 관심이 없어졌을 때 -1을 하면서
  카운팅이 0이 된다면, 모두가 보고있지 않은 액터로 판단해 소멸시키는 구조

문제점 : A -> B를 B -> A를 참조하는 경우 (A와 B는 컴포넌트)
	항상 0보다 크기때문에 메모리 누수가 발생하여 해당 메모리를 해제할 수 없음

따라서, 가비지 컬렉션이라고 하는 메모리 관리를 수행하는 방식이 존재함.

# 가비지 컬렉션
- 참조가 0인 것들을 바로 제거하지 않고, 여유가 있을 때 제거하는 방법
- 루트셋에서 시작하여 UPROPERTY를 따라가 도달할 수 없는 UObject인 경우
  가비지 컬렉션을 사용해 객체를 삭제한다.
- 스캔할 객체들의 집합을 가지고 있음

# 언리얼은 참조 카운팅을 어떻게 사용하고 있을까?
1. 언리얼에서 객체를 세기 위해 어떻게 참조하는가
 - TSharedPtr<AActor>을 이용함
   작동 방식 : 
                 1. 실제로 스택에 존재하는 TShared 포인터를 생성함
                 2. 따라서 스택에 존재하지만 힙에 있는 개체를 가리키고 있음.
                 3. 공유 포인터를 생성할 때, 가리키는 객체의 참조 횟수가 증가
                 4. 따라서, TShared 포인터가 유지될 때 힙에 있는 해당 객체는 사라지지 않음
                 
                 5. 스택을 롤백할 때, 스택에서 객체를 삭제하면 TShared 포인터가 사라질 수
	        있음
                 6. 따라서, TShared 포인터를 소멸시킬 때 참조 카운트가 매우 유용함(?)
                    왜? 참조횟수가 0이되면 결국 스택의 메모리가 지워지기 때문
                    순환 참조만 없다면 메모리 누수로 끝나진 않음


2. 언리얼이 가비지 컬렉션을 위해 스캔할 객체를 알게하는데 어떤 코드를 사용하는가
 - Garbage Collection in Unreal (언리얼에서 가비지 컬렉션이 수행되는 방식)
  1. 실제 가비지 컬렉션은 모든 UObject에 대해 자동으로 실행됨
  2. 모든 UObject는 가비지 컬렉션의 일부가 됨.
  3. 언리얼은 "root set"에서 시작되는데 루트셋에 UObject를 배치하기 위해 호출하는 
     함수가 있음
  4. 이 루트셋이 가비지 컬렉션이 시작되는 지점이다!

  5. 그곳에서부터 "UPROPERTY" 포인터를 따라 이동하게 됨
     따라서, UObject에서 UPROPERTY인 것은 자동으로 가비지 컬렉션의 대상이 된다.
 
  6. 다른 오브젝트에 대한 UPROPERTY 포인터가 존재한다면, 
     적어도 해당 오브젝트가 할당되지 않으면 UObject가 사라지지 않을 것이라 안전하다고 
     확신할 수 있음 (아무것도 객체를 가리키지 않는다면 제거하는 것이 공정하다!)

  7. 따라서 해당 링크를 따라 각각의 새 프로퍼티를 통해 발견되지 않은 새 객체는
     언리얼이 원할 때 마다 가비지 컬렉션으로 삭제할 수 있다.
# 따라서, 이는 공유 포인터가 
   UObject가 되지 않을 인터페이스를 다루고 있다는 것을 보여줌


3. 언리얼은 어떤 포인터를 따라야 하는지 어떻게 알 수 있는가





